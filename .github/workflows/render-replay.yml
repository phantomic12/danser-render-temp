name: Render osu! Replay

on:
  workflow_dispatch:
    inputs:
      replayFile:
        description: 'Path to the replay file in the repository'
        required: true
      discordMessageId:
        description: 'Discord message ID that triggered the render'
        required: true
      discordChannelId:
        description: 'Discord channel ID where to post the result'
        required: true
      uploadDestination:
        description: 'Where to upload the video (discord, youtube, or both)'
        required: true
        default: 'youtube'

jobs:
  render:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg libgl1-mesa-dev libx11-dev libxcursor-dev libxinerama-dev libxrandr-dev libxrender-dev xvfb curl jq firefox unzip
      
      - name: Setup Xvfb virtual display
        run: |
          export DISPLAY=:1
          Xvfb :1 -screen 0 1920x1080x24 &
          sleep 2
          # Test if xrandr can query the display
          if command -v xrandr &> /dev/null; then
            xrandr --query || echo "xrandr query failed but continuing anyway"
          fi
          echo "DISPLAY=:1" >> $GITHUB_ENV
      
      - name: Download and setup danser-go
        run: |
          # Get latest release URL
          LATEST_RELEASE_URL=$(curl -s https://api.github.com/repos/Wieku/danser-go/releases/latest | jq -r '.assets[] | select(.name | contains("linux")) | .browser_download_url')
          echo "Downloading from: $LATEST_RELEASE_URL"
          
          # Download and extract
          mkdir -p danser
          cd danser
          
          # Download file with proper extension
          if [[ "$LATEST_RELEASE_URL" == *.zip ]]; then
            curl -L -o danser.zip "$LATEST_RELEASE_URL"
            unzip danser.zip
          elif [[ "$LATEST_RELEASE_URL" == *.tar.gz ]]; then
            curl -L -o danser.tar.gz "$LATEST_RELEASE_URL"
            tar -xzf danser.tar.gz
          else
            echo "Unknown format, downloading as zip and trying both extraction methods"
            curl -L -o danser.archive "$LATEST_RELEASE_URL"
            unzip danser.archive || tar -xzf danser.archive || echo "Extraction failed, trying to continue"
          fi
          
          # List files to debug
          echo "Extracted files:"
          ls -la
          
          # Make all possible executable files executable
          chmod +x danser* 2>/dev/null || true
          
          # Create necessary directories
          mkdir -p ~/.config/danser
          mkdir -p ~/.local/share/danser/Songs
          mkdir -p ~/.local/share/danser/Replays
          mkdir -p ~/.local/share/danser/videos
          
      - name: Setup Python for OSR parsing
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          
      - name: Install OSR parsing dependencies
        run: |
          pip install osrparse requests

      - name: Copy replay file and extract beatmap info
        run: |
          cp ${{ github.workspace }}/${{ github.event.inputs.replayFile }} ~/.local/share/danser/Replays/
          REPLAY_FILENAME=$(basename ${{ github.event.inputs.replayFile }})
          echo "REPLAY_FILENAME=${REPLAY_FILENAME}" >> $GITHUB_ENV
          
          # Create Python script to extract beatmap_id and download it
          cat > extract_beatmap.py << 'EOL'
          import osrparse
          import requests
          import os
          import sys
          import zipfile
          import time
          
          def download_beatmap(beatmap_id):
              # Use chimu.moe as the primary source
              beatmap_url = f"https://chimu.moe/d/{beatmap_id}"
              alt_url = f"https://api.chimu.moe/v1/download/{beatmap_id}?n=1"
              
              try:
                  print(f"Downloading beatmap {beatmap_id} from {alt_url}")
                  response = requests.get(alt_url, stream=True, timeout=30)
                  
                  if response.status_code == 200:
                      # Create Songs directory if it doesn't exist
                      songs_dir = os.path.expanduser("~/.local/share/danser/Songs")
                      os.makedirs(songs_dir, exist_ok=True)
                      
                      # Save the beatmap
                      beatmap_file = os.path.join(songs_dir, f"{beatmap_id}.osz")
                      with open(beatmap_file, 'wb') as f:
                          for chunk in response.iter_content(chunk_size=8192):
                              f.write(chunk)
                      
                      print(f"Downloaded beatmap to {beatmap_file}")
                      
                      # Extract the beatmap
                      beatmap_dir = os.path.join(songs_dir, str(beatmap_id))
                      os.makedirs(beatmap_dir, exist_ok=True)
                      
                      try:
                          with zipfile.ZipFile(beatmap_file, 'r') as zip_ref:
                              zip_ref.extractall(beatmap_dir)
                          print(f"Extracted beatmap to {beatmap_dir}")
                          return True
                      except zipfile.BadZipFile:
                          print("Error: Downloaded file is not a valid beatmap archive")
                          return False
                  else:
                      print(f"Error: Failed to download beatmap, status code: {response.status_code}")
                      return False
              except Exception as e:
                  print(f"Error downloading beatmap: {e}")
                  
                  # Try alternative source (kitsu.moe)
                  try:
                      kitsu_url = f"https://kitsu.moe/api/d/{beatmap_id}"
                      print(f"Trying alternative source: {kitsu_url}")
                      response = requests.get(kitsu_url, stream=True, timeout=30)
                      
                      if response.status_code == 200:
                          # Save the beatmap
                          songs_dir = os.path.expanduser("~/.local/share/danser/Songs")
                          beatmap_file = os.path.join(songs_dir, f"{beatmap_id}.osz")
                          with open(beatmap_file, 'wb') as f:
                              for chunk in response.iter_content(chunk_size=8192):
                                  f.write(chunk)
                          
                          # Extract the beatmap
                          beatmap_dir = os.path.join(songs_dir, str(beatmap_id))
                          os.makedirs(beatmap_dir, exist_ok=True)
                          
                          with zipfile.ZipFile(beatmap_file, 'r') as zip_ref:
                              zip_ref.extractall(beatmap_dir)
                          print(f"Extracted beatmap from alternative source to {beatmap_dir}")
                          return True
                      else:
                          print(f"Error: Failed to download from alternative source, status code: {response.status_code}")
                          return False
                  except Exception as alt_e:
                      print(f"Error downloading from alternative source: {alt_e}")
                      return False
          
          def main():
              if len(sys.argv) < 2:
                  print("Usage: python extract_beatmap.py <replay_file>")
                  return 1
              
              replay_file = sys.argv[1]
              
              try:
                  # Parse the replay file - use the correct API call
                  # The API has changed in recent versions of osrparse
                  try:
                      # Try with newer API
                      from osrparse import parse_replay
                      replay = parse_replay(replay_file)
                  except (ImportError, AttributeError):
                      # Try with older API
                      try:
                          from osrparse import ReplayFile
                          replay = ReplayFile.parse_replay_file(replay_file)
                      except (ImportError, AttributeError):
                          # Try another variant of the API
                          from osrparse import Replay
                          replay = Replay.from_path(replay_file)
                  
                  # Extract beatmap info
                  beatmap_hash = getattr(replay, 'beatmap_hash', None)
                  beatmap_id = getattr(replay, 'beatmap_id', None)
                  
                  print(f"Parsed replay file: {replay_file}")
                  print(f"Beatmap Hash: {beatmap_hash}")
                  print(f"Beatmap ID: {beatmap_id}")
                  
                  # Set environment variables for GitHub Actions
                  with open(os.environ['GITHUB_ENV'], 'a') as env_file:
                      if beatmap_id:
                          env_file.write(f"BEATMAP_ID={beatmap_id}\n")
                      if beatmap_hash:
                          env_file.write(f"BEATMAP_HASH={beatmap_hash}\n")
                  
                  # Download the beatmap
                  if beatmap_id:
                      for attempt in range(3):  # Try up to 3 times
                          if download_beatmap(beatmap_id):
                              return 0
                          print(f"Retrying download ({attempt+1}/3)...")
                          time.sleep(2)  # Wait before retrying
                      
                      print("Failed to download beatmap after multiple attempts")
                      return 1
                  else:
                      print("Error: Could not determine beatmap ID from replay file")
                      return 1
                      
              except Exception as e:
                  print(f"Error parsing replay file: {e}")
                  print("Detailed exception information:")
                  import traceback
                  traceback.print_exc()
                  return 1
              
          if __name__ == "__main__":
              sys.exit(main())
          EOL
          
          # Run the script to extract and download beatmap
          python extract_beatmap.py ~/.local/share/danser/Replays/$REPLAY_FILENAME
      
      - name: Create default settings
        run: |
          cat > ~/.config/danser/settings.json << EOL
          {
            "General": {
              "DiscordPresenceOn": false,
              "OsuSongsDir": "/home/runner/.local/share/danser/Songs",
              "OsuSkinsDir": "/home/runner/.local/share/danser/Skins",
              "Output": "/home/runner/.local/share/danser/videos"
            },
            "Recording": {
              "FrameWidth": 1280,
              "FrameHeight": 720,
              "FPS": 60,
              "Encoder": "libx264"
            },
            "Graphics": {
              "VSync": false,
              "ShowFPS": false,
              "MSAA": 0,
              "Renderer": "GLES"
            }
          }
          EOL
          
      - name: Run danser rendering
        run: |
          cd danser
          # Use software rendering as a fallback if hardware rendering fails
          export LIBGL_ALWAYS_SOFTWARE=1
          
          # Check for available binaries
          echo "Looking for danser binary..."
          if [ -f "./danser" ]; then
            DANSER_BINARY="./danser"
          elif [ -f "./danser-cli" ]; then
            DANSER_BINARY="./danser-cli"
          else
            # As a last resort, find any executable
            DANSER_BINARY=$(find . -type f -executable | grep -E 'danser|danser-cli|danser-go' | head -1)
          fi
          
          if [ -z "$DANSER_BINARY" ]; then
            echo "Error: No suitable danser binary found!"
            ls -la
            exit 1
          fi
          
          echo "Using danser binary at: $DANSER_BINARY"
          
          # First try with downloaded beatmap
          if [ -n "$BEATMAP_ID" ]; then
            echo "Rendering with beatmap ID: $BEATMAP_ID"
            xvfb-run -a $DANSER_BINARY -replay="$REPLAY_FILENAME" -beatmap="$BEATMAP_ID" -quickstart -record -out="../render.mp4" || \
            xvfb-run -a $DANSER_BINARY -replay="$REPLAY_FILENAME" -quickstart -record -out="../render.mp4"
          else
            # Fallback to default quickstart without beatmap ID
            echo "Rendering with default quickstart"
            xvfb-run -a $DANSER_BINARY -replay="$REPLAY_FILENAME" -quickstart -record -out="../render.mp4"
          fi
          
          mv ../render.mp4 ~/.local/share/danser/videos/
      
      - name: Upload rendered video as artifact
        uses: actions/upload-artifact@v4
        with:
          name: rendered-replay
          path: ~/.local/share/danser/videos/*.mp4
      
      - name: Find video file
        id: find-video
        run: |
          VIDEO_PATH=$(find ~/.local/share/danser/videos -name "*.mp4" -type f -print -quit)
          echo "VIDEO_PATH=${VIDEO_PATH}" >> $GITHUB_ENV
          echo "VIDEO_FILENAME=$(basename ${VIDEO_PATH})" >> $GITHUB_ENV
          
          # Get file size for decision making
          FILE_SIZE_BYTES=$(stat -c%s "$VIDEO_PATH")
          FILE_SIZE_MB=$((FILE_SIZE_BYTES / 1024 / 1024))
          echo "FILE_SIZE_MB=${FILE_SIZE_MB}" >> $GITHUB_ENV
          echo "Video file size: ${FILE_SIZE_MB}MB"

      - name: Checkout Firefox profile repository
        if: github.event.inputs.uploadDestination != 'discord'
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.FIREFOX_PROFILE_REPO }}
          token: ${{ secrets.FIREFOX_PROFILE_TOKEN }}
          path: firefox-profile
          
      - name: Setup Python for Selenium
        if: github.event.inputs.uploadDestination != 'discord'
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
          
      - name: Install youtube-uploader-selenium
        if: github.event.inputs.uploadDestination != 'discord'
        run: |
          pip install youtube-uploader-selenium
          pip install selenium
          wget https://github.com/mozilla/geckodriver/releases/download/v0.32.0/geckodriver-v0.32.0-linux64.tar.gz
          tar -xzf geckodriver-v0.32.0-linux64.tar.gz
          sudo mv geckodriver /usr/local/bin/
      
      - name: Create metadata for YouTube
        if: github.event.inputs.uploadDestination != 'discord'
        run: |
          # Add beatmap info to the title if available
          if [ -n "$BEATMAP_ID" ]; then
            TITLE="osu! replay: $REPLAY_FILENAME (Beatmap ID: $BEATMAP_ID)"
          else
            TITLE="osu! replay: $REPLAY_FILENAME"
          fi
          
          cat > youtube_metadata.json << EOL
          {
            "title": "$TITLE",
            "description": "Rendered with danser-go. Original Discord message: https://discord.com/channels/${{ secrets.DISCORD_SERVER_ID }}/${{ github.event.inputs.discordChannelId }}/${{ github.event.inputs.discordMessageId }}",
            "tags": ["osu", "replay", "danser", "gameplay"],
            "privacyStatus": "unlisted"
          }
          EOL
          
      - name: Upload to YouTube using Selenium
        if: github.event.inputs.uploadDestination != 'discord'
        id: selenium-upload
        run: |
          # Ensure Xvfb is running for Selenium
          export DISPLAY=:1
          python - << EOF
          from youtube_uploader_selenium import YouTubeUploader
          import json
          import os
          
          video_path = os.environ['VIDEO_PATH']
          metadata_path = 'youtube_metadata.json'
          
          uploader = YouTubeUploader(video_path, metadata_path, 
                                     profile_path='firefox-profile/firefox_profile',
                                     browser_preference='firefox')
                                     
          was_upload_successful, video_id = uploader.upload()
          
          if was_upload_successful:
              print("::set-output name=video_id::{}".format(video_id))
              print("YOUTUBE_VIDEO_ID={}".format(video_id), file=open(os.environ['GITHUB_ENV'], 'a'))
              print("YOUTUBE_URL=https://youtu.be/{}".format(video_id), file=open(os.environ['GITHUB_ENV'], 'a'))
              print("Video successfully uploaded to YouTube with ID: {}".format(video_id))
          else:
              print("::error::Failed to upload video to YouTube")
              exit(1)
          EOF
        
      - name: Upload video to Discord (File)
        if: github.event.inputs.uploadDestination == 'discord' && env.FILE_SIZE_MB <= 25
        uses: tsickert/discord-webhook@v7.0.0
        with:
          webhook-url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          content: "Replay rendering complete! Original message: https://discord.com/channels/${{ secrets.DISCORD_SERVER_ID }}/${{ github.event.inputs.discordChannelId }}/${{ github.event.inputs.discordMessageId }}"
          filename: ${{ env.VIDEO_FILENAME }}
          file-path: ${{ env.VIDEO_PATH }}
      
      - name: Send YouTube link to Discord
        if: github.event.inputs.uploadDestination != 'discord' && env.YOUTUBE_URL != ''
        uses: tsickert/discord-webhook@v7.0.0
        with:
          webhook-url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          content: "Replay rendering complete! Video uploaded to YouTube: ${{ env.YOUTUBE_URL }} \nOriginal message: https://discord.com/channels/${{ secrets.DISCORD_SERVER_ID }}/${{ github.event.inputs.discordChannelId }}/${{ github.event.inputs.discordMessageId }}" 
